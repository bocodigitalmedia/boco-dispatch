// Generated by CoffeeScript 1.11.1
var configure,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

configure = function(arg) {
  var CallbackIdNotUnique, CallbackNotRegistered, CallbackStates, CannotDispatch, Dispatch, Dispatcher, Exception, HasCircularDependency, UUID;
  UUID = (arg != null ? arg : {}).UUID;
  if (typeof require === 'function') {
    if (UUID == null) {
      UUID = (function() {
        try {
          return require('uuid');
        } catch (error) {}
      })();
    }
  }
  CallbackStates = {
    WAITING: 0,
    PENDING: 1,
    HANDLED: 2
  };
  Exception = (function(superClass) {
    extend(Exception, superClass);

    Exception.prototype.message = null;

    Exception.prototype.payload = null;

    Exception.prototype.name = null;

    function Exception(payload) {
      this.payload = payload;
      this.message = this.getMessage(payload);
      this.name = this.constructor.name;
      Error.captureStackTrace(this, this.constructor);
    }

    Exception.prototype.getMessage = function() {
      return this.constructor.name;
    };

    return Exception;

  })(Error);
  HasCircularDependency = (function(superClass) {
    extend(HasCircularDependency, superClass);

    function HasCircularDependency() {
      return HasCircularDependency.__super__.constructor.apply(this, arguments);
    }

    HasCircularDependency.prototype.getMessage = function(arg1) {
      var id;
      id = arg1.id;
      return "Circular dependency detected while waiting for `" + id + "`";
    };

    return HasCircularDependency;

  })(Exception);
  CannotDispatch = (function(superClass) {
    extend(CannotDispatch, superClass);

    function CannotDispatch() {
      return CannotDispatch.__super__.constructor.apply(this, arguments);
    }

    CannotDispatch.prototype.getMessage = function(arg1) {
      var dispatcher;
      dispatcher = arg1.dispatcher;
      return "Cannot dispatch, current dispatch not finished.";
    };

    return CannotDispatch;

  })(Exception);
  CallbackIdNotUnique = (function(superClass) {
    extend(CallbackIdNotUnique, superClass);

    function CallbackIdNotUnique() {
      return CallbackIdNotUnique.__super__.constructor.apply(this, arguments);
    }

    CallbackIdNotUnique.prototype.getMessage = function(arg1) {
      var id;
      id = arg1.id;
      return "Callback id is not unique: `" + id + "`";
    };

    return CallbackIdNotUnique;

  })(Exception);
  CallbackNotRegistered = (function(superClass) {
    extend(CallbackNotRegistered, superClass);

    function CallbackNotRegistered() {
      return CallbackNotRegistered.__super__.constructor.apply(this, arguments);
    }

    CallbackNotRegistered.prototype.getMessage = function(arg1) {
      var id;
      id = arg1.id;
      return "Callback not registered: `" + id + "`";
    };

    return CallbackNotRegistered;

  })(Exception);
  Dispatch = (function() {
    Dispatch.prototype.dispatcher = null;

    Dispatch.prototype.payload = null;

    Dispatch.prototype.callbackStates = null;

    function Dispatch(props) {
      var key, val;
      for (key in props) {
        if (!hasProp.call(props, key)) continue;
        val = props[key];
        this[key] = val;
      }
      if (this.callbackStates == null) {
        this.callbackStates = {};
      }
    }

    Dispatch.prototype.getState = function(id) {
      var ref;
      return (ref = this.callbackStates[id]) != null ? ref : CallbackStates.WAITING;
    };

    Dispatch.prototype.setState = function(id, state) {
      return this.callbackStates[id] = state;
    };

    Dispatch.prototype.setPending = function(id) {
      return this.setState(id, CallbackStates.PENDING);
    };

    Dispatch.prototype.setHandled = function(id) {
      return this.setState(id, CallbackStates.HANDLED);
    };

    Dispatch.prototype.isPending = function(id) {
      return this.getState(id) === CallbackStates.PENDING;
    };

    Dispatch.prototype.isHandled = function(id) {
      return this.getState(id) === CallbackStates.HANDLED;
    };

    Dispatch.prototype.isWaiting = function(id) {
      return this.getState(id) === CallbackStates.WAITING;
    };

    Dispatch.prototype.send = function() {
      this.callbackStates = {};
      return this.dispatcher.getCallbackIds().forEach((function(_this) {
        return function(id) {
          if (_this.isWaiting(id)) {
            return _this.invokeCallback(id);
          }
        };
      })(this));
    };

    Dispatch.prototype.invokeCallback = function(id) {
      this.setPending(id);
      this.dispatcher.getCallback(id)(this);
      return this.setHandled(id);
    };

    Dispatch.prototype.waitFor = function() {
      var ids;
      ids = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return ids.forEach((function(_this) {
        return function(id) {
          if (_this.isPending(id)) {
            throw new HasCircularDependency({
              id: id
            });
          }
          if (!_this.isHandled(id)) {
            return _this.invokeCallback(id);
          }
        };
      })(this));
    };

    return Dispatch;

  })();
  Dispatcher = (function() {
    Dispatcher.prototype.callbacks = null;

    Dispatcher.prototype.currentDispatch = null;

    function Dispatcher(props) {
      var key, val;
      for (key in props) {
        if (!hasProp.call(props, key)) continue;
        val = props[key];
        this[key] = val;
      }
      if (this.callbacks == null) {
        this.callbacks = {};
      }
      if (this.currentDispatch == null) {
        this.currentDispatch = null;
      }
    }

    Dispatcher.prototype.generateCallbackId = function() {
      return UUID();
    };

    Dispatcher.prototype.hasCallback = function(id) {
      return this.callbacks[id] != null;
    };

    Dispatcher.prototype.getCallback = function(id) {
      if (!this.hasCallback(id)) {
        throw new CallbackNotRegistered({
          id: id
        });
      }
      return this.callbacks[id];
    };

    Dispatcher.prototype.getCallbackIds = function() {
      var id, ref, results;
      ref = this.callbacks;
      results = [];
      for (id in ref) {
        if (!hasProp.call(ref, id)) continue;
        results.push(id);
      }
      return results;
    };

    Dispatcher.prototype.setCallback = function(id, callback) {
      if (this.hasCallback(id)) {
        throw new CallbackIdNotUnique({
          id: id
        });
      }
      return this.callbacks[id] = callback;
    };

    Dispatcher.prototype.register = function(callback, id) {
      if (id == null) {
        id = this.generateCallbackId();
      }
      this.setCallback(id, callback);
      return id;
    };

    Dispatcher.prototype.unregister = function(id) {
      if (!this.hasCallback(id)) {
        throw new CallbackNotRegistered({
          id: id
        });
      }
      return delete this.callbacks[id];
    };

    Dispatcher.prototype.isDispatching = function() {
      return this.currentDispatch != null;
    };

    Dispatcher.prototype.dispatch = function(payload) {
      if (this.isDispatching()) {
        throw new CannotDispatch({
          dispatcher: this
        });
      }
      this.currentDispatch = new Dispatch({
        dispatcher: this,
        payload: payload
      });
      this.currentDispatch.send();
      return delete this.currentDispatch;
    };

    return Dispatcher;

  })();
  return {
    configure: configure,
    CallbackStates: CallbackStates,
    Exception: Exception,
    HasCircularDependency: HasCircularDependency,
    CannotDispatch: CannotDispatch,
    CallbackIdNotUnique: CallbackIdNotUnique,
    CallbackNotRegistered: CallbackNotRegistered,
    Dispatch: Dispatch,
    Dispatcher: Dispatcher
  };
};

module.exports = configure();

//# sourceMappingURL=index.js.map
